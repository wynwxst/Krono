#include "misc/base.hpp"
#include "tcp/server.hpp"


#ifndef PROC
#define PROC
#define RESET "\033[0m"
#define RED   "\033[31m"
#define GREEN "\033[32m"
#define YELLOW "\033[33m"
#define CYAN  "\033[36m"
#define MAGENTA "\033[35m"

#include <lldb/API/LLDB.h>
#include <cstdio>
#include <memory>
#include <string>
#include <thread>
#include <mutex>
#include <queue>
#include <condition_variable>



struct activeProcess {
    public:
    activeProcess(std::shared_ptr<lldb::SBProcess> AP,std::shared_ptr<lldb::SBTarget> T): activeProc(AP), target(T) {

    }
    std::shared_ptr<lldb::SBProcess> activeProc;
    std::shared_ptr<lldb::SBTarget> target;
};

class Process {
    public:
    lldb::SBDebugger debugger;
    std::vector<std::shared_ptr<lldb::SBBreakpoint>> breakpoints;
    std::vector<std::shared_ptr<lldb::SBBreakpoint>> inputbps;
    std::shared_ptr<TCPServer> server;
    lldb::SBListener listener;
    
    Process(std::shared_ptr<TCPServer> server): server(server){
        lldb::SBDebugger::Initialize();

        debugger = lldb::SBDebugger::Create();
        debugger.SetAsync(false);

    }

    void set_unbuffered(lldb::SBProcess &process) {
        std::cout << "Called back" << std::endl;
        lldb::SBThread thread = process.GetSelectedThread();
        lldb::SBFrame frame = thread.GetSelectedFrame();
        frame.EvaluateExpression("(void)setvbuf(stdout, NULL, _IONBF, 0)");
    }

    lldb::SBProcess Attach(int pid){
        /*std::shared_ptr<lldb::SBProcess> process = target.AttachToProcessWithID(debugger.GetListener(), pid, err);
        if (!process->IsValid()) {
            std::cerr << "Attach failed: " << err.GetCString() << std::endl;
            return false;
        }*/

    }

    bool isDarwin = false;
    bool create_lldb_prefix_file(const std::string& path) {
        std::cout << "Creating prefix file at: " << path << std::endl;
        std::ofstream outfile(path);
        if (!outfile) {
            std::cerr << "Error: Could not open file for writing: " << path << std::endl;
            return false;
        }

        #if defined(__APPLE__)

        outfile << "// Auto-generated by configuration helper\n";
        outfile << "struct __sFILE;\n";
        outfile << "typedef struct __sFILE FILE;\n";
        outfile << "extern FILE *__stdoutp;\n"; // I believe this would not work on linux, nor windows.
        outfile << "#define STDOUT __stdoutp\n";
        #endif
        #if defined(__linux__)

        outfile << "// Auto-generated by configuration helper\n";
        outfile << "struct _IO_FILE;\n";
        outfile << "typedef struct _IO_FILE FILE;\n";
        outfile << "extern FILE *stdout;\n"; 
        outfile << "#define STDOUT stdout\n";
        #endif
        #if defined(_WIN32)

        outfile << "// Auto-generated by configuration helper\n";
        outfile << "struct _iobuf;\n";
        outfile << "typedef struct _iobuf FILE;\n";
        outfile << "extern FILE *stdout;\n"; // I believe this would not work on linux, nor windows.
        outfile << "#define STDOUT stdout\n";
        #endif
        //typedef struct _IO_FILE FILE;

        outfile.close();
        
        return true;
    }
    std::string prefix_loc;

    bool configureLLDBPlatform(lldb::SBDebugger& debugger) {
        std::cout << "Configuring for the current platform..." << std::endl;


        std::string prefix_path = "/tmp/krono_prefix.h";
    #ifdef _WIN32
        // Use %TEMP% on Windows
        char* temp_path_env = nullptr;
        size_t len;
        errno_t err = _dupenv_s(&temp_path_env, &len, "TEMP");
        if (err == 0 && temp_path_env != nullptr) {
            prefix_path = std::string(temp_path_env) + "\\krono_prefix.h";
            free(temp_path_env);
        } else {
            std::cerr << "Warning: Could not find TEMP environment variable. Using a default path." << std::endl;
            prefix_path = "C:\\Temp\\krono_prefix.h";
        }
    #endif
    

        if (!create_lldb_prefix_file(prefix_path)) {
            return false;
        }
        prefix_loc = prefix_path;

        std::string command = "settings set target.expr-prefix '" + prefix_path + "'";
        debugger.HandleCommand(command.c_str());
        std::cout << "Set expression prefix to: " << prefix_path << std::endl;



    #if defined(__APPLE__)

        std::cout << "Platform: macOS detected." << std::endl;

    #elif defined(__linux__)
        std::cout << "Platform: Linux detected." << std::endl;

    #elif defined(_WIN32)
        std::cout << "Platform: Windows detected." << std::endl;
        std::cout << "Note: For Windows, please run from a pre-configured environment (e.g., Developer Command Prompt for VS) so LLDB can find system headers." << std::endl;
    #else
        #warning "Unrecognized platform. Expression evaluation may fail."
    #endif


        std::cout << "configuration complete." << std::endl;
        return true;
    }

    std::string expr_flags="";

    std::vector<std::string> launch_flags;



    activeProcess setTarget(std::string Binary,std::string target="native",std::string platform="native"){
        lldb::SBError err;
        lldb::SBPlatform hostPlatform = lldb::SBPlatform::GetHostPlatform();
        platform = hostPlatform.GetName();

        //debugger.SetSelectedPlatform(hostPlatform);

        lldb::SBTarget LaunchBin = debugger.CreateTarget(Binary.c_str(),nullptr,nullptr,true,err);
        configureLLDBPlatform(debugger);
        std::string triple = LaunchBin.GetTriple();

        isDarwin = triple.find("apple") != std::string::npos;

        debugger.SetAsync(true);
        if (!LaunchBin.IsValid()) {
            throw std::runtime_error("Invalid Launch Binary:\nBinary: " + Binary + "\nTarget: " + target + "\nPlatform: " + platform + "\nError: " + err.GetCString());
        }


        std::vector<std::string> inputFunctions = {
            // Libc
            "scanf",
            "fscanf",
            "fgets",
            "getchar",
            "getc",
            "getline",

            // POSIX
            "read",
            "fread",

            // Wingoes
            "_read",
            "_getch",
            "ReadConsoleA",
            "ReadConsoleW"
        };

        

        for (auto fn : inputFunctions){
            inputbps.push_back(std::make_shared<lldb::SBBreakpoint>(LaunchBin.BreakpointCreateByName(fn.c_str())));
        }

        auto bp = std::make_shared<lldb::SBBreakpoint>(LaunchBin.BreakpointCreateByName("main"));
        bp->AddName("Entry Point");
        breakpoints.push_back(bp);
        


        return activeProcess(nullptr,std::make_shared<lldb::SBTarget>(LaunchBin)); // printf("Process started with PID: %llu\n", process->GetProcessID());
    }

    activeProcess Launch(activeProcess aP){
        lldb::SBLaunchInfo launchInfo(nullptr);
        
        //launchInfo.SetLaunchFlags();
        lldb::SBError error;
        if (!launch_flags.empty()){
            uint32_t launchflags = 0;
            for (auto flag : launch_flags){
                if (flag == "stop_at_entry"){
                    launchflags |= lldb::eLaunchFlagStopAtEntry;
                }
            }
            launchInfo.SetLaunchFlags(launchflags);
        }
        auto process = std::make_shared<lldb::SBProcess>(aP.target->Launch(launchInfo, error));
        //LaunchBin.EvaluateExpression("(void)setvbuf(stdout, NULL, _IONBF, 0)");
        listener = debugger.GetListener();
        process->GetBroadcaster().AddListener(listener,
            lldb::SBProcess::eBroadcastBitStateChanged | lldb::SBProcess::eBroadcastBitSTDOUT);
        

        
        if (error.Fail()) {
            throw std::runtime_error(std::string("Failed to launch Binary: ") + error.GetCString());
        }
        return activeProcess(process,aP.target);
    }

    std::shared_ptr<std::string> input_buffer = std::make_shared<std::string>("");
    bool can_proceed = false;
    std::string backtrace_str = "";
    void _StayExec(std::shared_ptr<lldb::SBProcess> process,std::shared_ptr<lldb::SBTarget> target){


        lldb::SBEvent event;
        

        while (process->IsValid()) {
            if (listener.WaitForEvent(1, event)) { 
                if (lldb::SBProcess::EventIsProcessEvent(event)) {
                    lldb::StateType state = lldb::SBProcess::GetStateFromEvent(event);
                    int state_cmp = static_cast<int>(state) ;
                    uint32_t event_type = event.GetType();
                    //std::cout << "Run state: " << state << std::endl;
                    bool handled = false;

                    

                    if (state_cmp == lldb::eStateStopped) {
                        
                        for (uint32_t i = 0; i < process->GetNumThreads(); ++i) {
                            auto thread = process->GetThreadAtIndex(i);
                            if (thread.GetStopReason() == lldb::StopReason::eStopReasonBreakpoint){
                                backtrace_str.clear();
                                for (int fidx = 0; fidx < thread.GetNumFrames();fidx++){
                                    auto frme = thread.GetFrameAtIndex(fidx);
                                    if (frme.IsValid()){
                                        lldb::SBVariablesOptions opts;
                                        opts.SetIncludeArguments(true);
                                        opts.SetIncludeLocals(false);
                                        opts.SetIncludeStatics(false);
                                        opts.SetInScopeOnly(false); 
                                        auto args = frme.GetVariables(opts);
                                        std::stringstream ss;
                                        ss << "Frame #" << frme.GetFrameID() << " " << frme.GetFunctionName() << "(";
                                        for (int argi = 0; argi < args.GetSize();argi++){
                                            auto arg = args.GetValueAtIndex(argi);
                                            if (argi == args.GetSize()-1){
                                                ss << arg.GetName() << "=" << arg.GetValue();
                                            } else {
                                                ss << arg.GetName() << "=" << arg.GetValue() << ", ";
                                            }
                                        }
                                        ss << ") ";
                                        if (frme.GetLineEntry().IsValid()){
                                            ss << "[" <<  frme.GetLineEntry().GetFileSpec().GetFilename() << ", (" << frme.GetLineEntry().GetLine() << ":" <<  frme.GetLineEntry().GetColumn() << ")]";
                                        } else {
                                            ss << "[No Debug Information Provided]";
                                        }
                                        backtrace_str += ss.str() + "\n";
                                    }
                                    
                                }
                                lldb::break_id_t bp_id = thread.GetStopReasonDataAtIndex(0);
                                for (auto ibp : inputbps){
                                    if (bp_id == ibp->GetID()){
                                        lldb::SBExpressionOptions EO;
                                        debugger.HandleCommand("expr (int)fflush(STDOUT);");
                                        
                                        

                                        //std::cout << result.GetError().GetCString() << std::endl;
                                        
                                        process->Continue();
                                        server->sendMessage("input_required");
                                        server->sendMessage("begin_prompt");
                                        char buf[1024];
                                        size_t bytes_read = 0;
                                        do {
                                            bytes_read = process->GetSTDOUT(buf, sizeof(buf));
                                            if (bytes_read > 0) {
                                                server->sendMessage(std::string(buf, bytes_read));
                                            }
                                        } while (bytes_read > 0);
                                        server->sendMessage("end_prompt");
                                        can_proceed = false;
                                        
                                        *input_buffer = "";
                                        while (*input_buffer == ""){
                                            std::this_thread::sleep_for(std::chrono::milliseconds(30));
                                        }
                                        
                                        if (input_buffer->empty() || input_buffer->back() != '\n') input_buffer->push_back('\n');

                                        
                                        

                                        process->PutSTDIN(input_buffer->c_str(), input_buffer->size());
                                        *input_buffer = "";
                                        handled = true;
                                        while (can_proceed == false){
                                            std::this_thread::sleep_for(std::chrono::milliseconds(30));
                                        }
                                        
                                        //state = lldb::SBProcess::GetStateFromEvent(event);
                                        
                                        break;
                                    }
                                }
                                if (!handled){
                                    lldb::SBBreakpoint bp = process->GetTarget().FindBreakpointByID(bp_id);

                                    if (bp.IsValid()) {
                                        std::string stop_data;
                                        size_t needed = thread.GetStopDescription(nullptr, 0);
                                        std::string stop_reason(needed+1,'\0'); 
                                        thread.GetStopDescription(stop_reason.data(),needed);
                                        server->sendMessage("Process Stop Reason: " + stop_reason);
                                        server->sendMessage( "Frame #" + std::to_string(thread.GetSelectedFrame().GetFrameID()) + ": " + thread.GetSelectedFrame().GetFunctionName());
                                        std::string msg = "Breakpoint Hit:\n";
                                        std::stringstream ss;
                                        auto baseloc = bp.GetLocationAtIndex(0);
                                        ss << "0x" << std::hex << baseloc.GetAddress().GetLoadAddress(*target);
                                        lldb::SBStringList names;
                                        bp.GetNames(names);
                                        std::string bp_name = (names.GetSize() > 0) ? names.GetStringAtIndex(0) : "<unnamed>";
                                        msg  += "#" + std::to_string(bp.GetID()) + "  |" + ss.str() + ":   " +  bp_name +  " -- " + std::to_string(bp.GetHitCount())  + " [HIT]\n";
                                        server->sendMessage(msg);
                                        server->BroadcastUpdate();
                                        server->sendMessage(getDisasmPC(activeProcess(process,target)));

                                        
                                        
                                        
                                    }
                                    server->sendMessage("endloop");
                                    
                                    

                                    break;
                                } else {
                                    break;
                                }

                            } else {
                                std::string stop_data;
                                size_t needed = thread.GetStopDescription(nullptr, 0);
                                std::string stop_reason(needed+1,'\0'); 
                                thread.GetStopDescription(stop_reason.data(),needed);
                                server->sendMessage("Process Stop Reason: " + stop_reason);
                                server->sendMessage( "Frame #" + std::to_string(thread.GetSelectedFrame().GetFrameID()) + ": " + thread.GetSelectedFrame().GetFunctionName());
                                server->sendMessage(getDisasmPC(activeProcess(process,target)));
                                server->sendMessage("endloop");
                            }
                            

                        }

                        

                        
                    }

                    if (state_cmp == lldb::eStateExited ){
                        server->sendMessage("Process exited with code: " + std::to_string(process->GetExitStatus()));
                        server->sendMessage("endloop");
                        break;
                    }
                    if (event_type == lldb::SBProcess::eBroadcastBitSTDOUT){
                        char buf[1024];
                        size_t bytes_read = 0;
                        do {
                            bytes_read = process->GetSTDOUT(buf, sizeof(buf));
                            if (bytes_read > 0) {
                                server->sendMessage(std::string(buf, bytes_read));
                            }
                        } while (bytes_read > 0);
                    }
                    

                    std::this_thread::sleep_for(std::chrono::milliseconds(10));
                            }
            }
        }
        /*char buf[1024];
        size_t bytes_read;
        while ((bytes_read = process->GetSTDOUT(buf, sizeof(buf))) > 0) {
            server->sendMessage(std::string(buf));
        }*/
    }
    std::string getBackTrace(){
        return backtrace_str;
    }

    bool alreadyexec=false;

    void StayExec(std::shared_ptr<lldb::SBProcess> process,std::shared_ptr<lldb::SBTarget> target){
        if (!alreadyexec){
            std::cout << "Spawned thread" << std::endl;
            std::thread execThread([this, process,target]() {
            this->_StayExec(process,target);
            });
            execThread.detach();
            alreadyexec = true;
        }

    }

    void End(std::shared_ptr<lldb::SBProcess> process){
        process->Kill();
    }

    void Continue(std::shared_ptr<lldb::SBProcess> process){
        process->Continue();
    }

    void Stop(std::shared_ptr<lldb::SBProcess> process){
        process->Stop();
    }

    void Detach(std::shared_ptr<lldb::SBProcess> process,bool keepStopped=false){
        process->Detach(keepStopped);
    }

    void SetBreakOnName(activeProcess aP,std::string name){
        auto bp = std::make_shared<lldb::SBBreakpoint>(aP.target->BreakpointCreateByName(name.c_str()));
        bp->AddName(name.c_str());
        server->BroadcastSpecificUpdate("Breakpoints");
        breakpoints.push_back(bp);
    }

    void SetBreakOnAddress(activeProcess aP,uint64_t address,std::string name){
        auto bp = std::make_shared<lldb::SBBreakpoint>(aP.target->BreakpointCreateByAddress(address));
        bp->AddName(name.c_str());
        server->BroadcastSpecificUpdate("Breakpoints");
        breakpoints.push_back(bp);
    }

    std::string listModules(activeProcess aP) {
        auto target = aP.target;
        if (!target->IsValid()) {
            return "No target loaded.\n";
        }
        auto modules = target->GetNumModules();
        std::string info;
        for (int i = 0; i < modules; i++){
            auto module = target->GetModuleAtIndex(i);
            std::stringstream ss;
            auto baseSection = module.GetSectionAtIndex(0);
            ss << "0x" << std::hex << baseSection.GetLoadAddress(*target);
            char path[PATH_MAX];
            module.GetFileSpec().GetPath(path, sizeof(path));
            info  += ss.str() + ":   " +  std::string(module.GetFileSpec().GetFilename()) +" : " + std::string(path)  + "\n"; 
            for (int idx = 0; idx < module.GetNumSections();idx++){
                auto section = module.GetSectionAtIndex(idx);
                std::stringstream hx;
                hx << "0x" << std::hex << section.GetLoadAddress(*aP.target);
                info += hx.str()  + ":   ";
                if (idx == module.GetNumSections()-1){
                    info += "└─ ";
                    
                } else {
                    info += "├─ ";
                }
                info += std::string(section.GetName()) + " | " + std::to_string(section.GetPermissions()) + " | " + std::to_string(section.GetFileByteSize()) + "\n";
            }
            info += "<thinline>\n";

        }
        return info;
    }
    std::string listBreakPoints(activeProcess aP) {
        auto target = aP.target;
        if (!target->IsValid()) {
            return "No target loaded.\n";
        }
        std::string info;
        for (auto bp : breakpoints){
            std::stringstream ss;
            auto baseloc = bp->GetLocationAtIndex(0);
            ss << "0x" << std::hex << baseloc.GetAddress().GetLoadAddress(*target);
            lldb::SBStringList names;
            bp->GetNames(names);
            std::string bp_name = (names.GetSize() > 0) ? names.GetStringAtIndex(0) : "<unnamed>";
            info  += "#" + std::to_string(bp->GetID()) + "  |" + ss.str() + ":   " +  bp_name +  " -- " + std::to_string(bp->GetHitCount())  + "\n"; 
        }
        return info;
    }


    std::string getDisasmFunction(activeProcess aP,std::string func_name){
        std::string result;



        lldb::SBSymbolContextList func_list = aP.target->FindFunctions(func_name.c_str(), lldb::eFunctionNameTypeAuto);
        if (func_list.GetSize() == 0) {
            return "Function not found: " + func_name + "\n";
            
        }
        std::string signature;
        lldb::SBSymbolContext func_ctx;
        lldb::SBFunction func;
        lldb::SBAddress start;
        lldb::SBAddress end;
        for (int i = 0; i < func_list.GetSize();i++) {

            func_ctx = func_list.GetContextAtIndex(i);
            if (!func_ctx.IsValid()) {
                continue;
            }
            auto func = func_ctx.GetFunction();
            if (func.IsValid()) {
                break;
            }
        }
        if (func.IsValid()) {
            lldb::SBType func_type = func.GetType();
            if (!func_type.IsValid()) return "Invalid function type.\n";
            
            auto arg_types = func_type.GetFunctionArgumentTypes();
            signature += std::string(func_type.GetFunctionReturnType().GetName()) + " " + func.GetName() + "( ";

            int arg_idx = 1;
            for (int i = 0; i < arg_types.GetSize();i++){
                if (i == arg_types.GetSize()-1){
                    signature += std::string(arg_types.GetTypeAtIndex(i).GetName()) + " arg" + std::to_string(arg_idx) + + ")";
                } else {
                    signature += std::string(arg_types.GetTypeAtIndex(i).GetName()) + " arg" + std::to_string(arg_idx) + " , ";
                    arg_idx += 1;
                }

            }
            start = func.GetStartAddress();
            end = func.GetEndAddress();
        } else {
            lldb::SBSymbol symbol = func_ctx.GetSymbol();
            if (!symbol.IsValid()) return "Invalid symbol.\n";
            start = symbol.GetStartAddress();
            end = symbol.GetEndAddress();
            signature += std::string(symbol.GetName() )+ " -- Unable to read argument data";
        }
        signature += "\n";
        result += signature;



        if (!start.IsValid() || !end.IsValid()) {
            return "Invalid start/end addresses.\n";
        }
        result += getDisasm(aP,start.GetLoadAddress(*aP.target),end.GetLoadAddress(*aP.target));



        return result;
    }
    std::string disasmfixed;

    std::string getDisasmFixed(){
        return disasmfixed;
    }
    void setDisasmFixed(std::string dfxd){
        disasmfixed = dfxd;
        server->BroadcastSpecificUpdate("Disassembly (Fixed)");
    }

    std::string funcfixed;

    std::string getFuncFixed(){
        return funcfixed;
    }
    void setFuncFixed(std::string dfxd){
        funcfixed = dfxd;
        server->BroadcastSpecificUpdate("Functions");
    }

    std::string getDisasm(activeProcess aP,uint64_t start_addr,uint64_t end_addr){
        lldb::SBAddress start(start_addr,*aP.target);
        lldb::SBAddress end(end_addr,*aP.target);
        if (!start.IsValid() || !end.IsValid()) {
            return "Invalid start/end addresses.\n";
        }        
        std::string result;

        uint32_t byte_size = end.GetLoadAddress(*aP.target) - start.GetLoadAddress(*aP.target);
        lldb::SBInstructionList inst_list = aP.target->ReadInstructions(start,end,"intel");
        for (int i = 0; i < inst_list.GetSize(); i++){
            auto inst = inst_list.GetInstructionAtIndex(i);
            auto inst_addr = inst.GetAddress().GetLoadAddress(*aP.target);
            std::stringstream ss;
            ss << "0x" << std::hex << inst_addr;
            std::string prefix = "   ";
            result += prefix + RESET + ss.str() + ": " + CYAN +  inst.GetMnemonic(*aP.target) + RESET + " " + inst.GetOperands(*aP.target) + MAGENTA + "; " + inst.GetComment(*aP.target) + RESET + "\n";
        }
        return result;

    }

    std::string getDisasmInsts(activeProcess aP,uint64_t start_addr,uint32_t insts){
        lldb::SBAddress start(start_addr,*aP.target);
        if (!start.IsValid()) {
            return "Invalid start address.\n";
        }        
        std::string result;

        lldb::SBInstructionList inst_list = aP.target->ReadInstructions(start, insts,"intel");
        for (int i = 0; i < inst_list.GetSize(); i++){
            auto inst = inst_list.GetInstructionAtIndex(i);
            auto inst_addr = inst.GetAddress().GetLoadAddress(*aP.target);
            std::stringstream ss;
            ss << "0x" << std::hex << inst_addr;
            std::string prefix = "   ";
            result += prefix + RESET + ss.str() + ": " + CYAN +  inst.GetMnemonic(*aP.target) + RESET + " " + inst.GetOperands(*aP.target) + MAGENTA + "; " + inst.GetComment(*aP.target) + RESET + "\n";
        }
        return result;

    }

    std::string getDisasmPC(activeProcess aP,int before=3,int after=3){
        auto process = aP.activeProc;
        if (process->GetState() == lldb::StateType::eStateStopped){
            lldb::SBThread thread = process->GetSelectedThread();
            if (!thread.IsValid()) {
                return  "No valid thread.\n";
            }

            lldb::SBFrame frame = thread.GetSelectedFrame();
            if (!frame.IsValid()) {
                return "No valid frame.\n";
            }

            lldb::addr_t pc_addr = frame.GetPC();





            lldb::SBFunction func = frame.GetFunction();
            lldb::addr_t func_start_addr = 0;
            if (func.IsValid()) {
                func_start_addr = func.GetStartAddress().GetLoadAddress(*aP.target);
            } else {
                lldb::SBSection text_sec = frame.GetModule().FindSection(".text");
                if (text_sec.IsValid())
                    func_start_addr = text_sec.GetLoadAddress(*aP.target);
            }


            lldb::addr_t start_addr = func_start_addr;

            int max_back_bytes = 15 * before;
            if (pc_addr > (lldb::addr_t)max_back_bytes && func_start_addr > 0){
                start_addr = std::max(pc_addr - max_back_bytes, func_start_addr);
            } else {
                start_addr = pc_addr;
            }
            uint32_t max_count = before + after + 10;
            lldb::SBInstructionList insts = aP.target->ReadInstructions(lldb::SBAddress(start_addr, *aP.target), max_count,"intel");
            if (insts.GetSize() == 0) return "No instructions.\n";


            int current_index = -1;
            for (uint32_t i = 0; i < insts.GetSize(); i++) {
                lldb::SBInstruction inst = insts.GetInstructionAtIndex(i);
                lldb::addr_t inst_addr = inst.GetAddress().GetLoadAddress(*aP.target);
                if (inst_addr <= pc_addr && pc_addr < inst_addr + inst.GetByteSize()) {
                    current_index = i;
                    break;
                }
            }
            if (current_index == -1) return "Unable to find PC";
            std::string result;
            int start = std::max(0, current_index - before);
            int end   = std::min((int)insts.GetSize() - 1, current_index + after);

            for (int i = start; i <= end; i++){
                auto inst = insts.GetInstructionAtIndex(i);
                auto inst_addr = inst.GetAddress().GetLoadAddress(*aP.target);
                std::stringstream ss;
                ss << "0x" << std::hex << inst_addr;
                std::string prefix = (inst_addr == pc_addr) ? (RED+ std::string("=> ")) : "   ";
                result += prefix + RESET + ss.str() + ": " + CYAN +  inst.GetMnemonic(*aP.target) + RESET + " " + inst.GetOperands(*aP.target) + MAGENTA + "; " + inst.GetComment(*aP.target) + RESET + "\n";
            }
            return result;
        } else {
            return "Not in stopped state.\n";
        }

        
    }
    std::string listFunctions(activeProcess aP,std::string modulename){
        lldb::SBModule module;
        if (modulename != ""){
            int modules = aP.target->GetNumModules();
            for (int i = 0; i < modules; i++){
                if (aP.target->GetModuleAtIndex(i).GetFileSpec().GetFilename() == modulename){
                    module = aP.target->GetModuleAtIndex(i);
                    break;
                }
            }
        } else {
            module = aP.target->GetModuleAtIndex(0);
        }
        if (!module.IsValid()){
            return "invalid module";
        }
        std::string result = "Functions for: " + std::string(module.GetFileSpec().GetFilename());
        result += "\n<thinline>\n";



        for (uint32_t i = 0; i < module.GetNumSymbols(); i++) {
            lldb::SBSymbol sym = module.GetSymbolAtIndex(i);
            if (sym.IsValid() && sym.GetName() != nullptr) {
                auto ctx = lldb::SBSymbolContext();
                ctx.SetSymbol(sym);
                auto func = ctx.GetFunction();
                std::string signature;
                if (func.IsValid()){
                    auto func_type = func.GetType();
                    if (func_type.IsValid()){
                        auto arg_types = func_type.GetFunctionArgumentTypes();
                        signature += std::string(func_type.GetFunctionReturnType().GetName()) + " " + func.GetName() + "( ";

                        int arg_idx = 1;
                        for (int i = 0; i < arg_types.GetSize();i++){
                            if (i == arg_types.GetSize()-1){
                                signature += std::string(arg_types.GetTypeAtIndex(i).GetName()) + " arg" + std::to_string(arg_idx) + + ")";
                            } else {
                                signature += std::string(arg_types.GetTypeAtIndex(i).GetName()) + " arg" + std::to_string(arg_idx) + " , ";
                                arg_idx += 1;
                            }

                        }
                    } else {
                        signature = sym.GetName();
                    }
                } else {
                    signature = sym.GetName();
                }
                std::stringstream ss;
                ss << "0x" << std::hex << sym.GetStartAddress().GetLoadAddress(*aP.target) << "-" << sym.GetEndAddress().GetLoadAddress(*aP.target);
                result += ss.str() + ": " +  signature + "\n";
                
            }
        }
        return result;
    }

    std::string peek_ascii(lldb::SBProcess &process, lldb::addr_t addr, size_t maxlen=8) {
        lldb::SBError error;
        std::vector<char> buf(maxlen+2, 0);
        size_t n = process.ReadMemory(addr, buf.data(), maxlen+1, error);
        if (error.Fail() || n == 0)
            return "";
        if (n > 8){
            n = 9;
        }


        std::string out;
        size_t printed = 0;

        for (size_t i = 0; i < n; i++) {
            unsigned char c = buf[i];
            if (c == 0) break;
            if (!isprint(c)) break;
            if (printed < maxlen) {
                out.push_back(c);
            }
            printed++;
        }

        if (printed > maxlen) {
            out += "...";
        }
        return out;
    }

    std::string hexStr(uint64_t addr){
        std::stringstream ss;
        ss << "0x" << std::hex << addr;
        return ss.str();
    }

    std::string viewStack(activeProcess aP){
        std::string result;
        auto process = aP.activeProc;
        lldb::SBThread thread = process->GetSelectedThread();
        lldb::SBFrame frame = thread.GetSelectedFrame();

        if (!frame.IsValid()) {
            return "No valid frame.\n";
        }

        lldb::addr_t sp = frame.GetSP();
        lldb:: addr_t fp = frame.GetFP();
        size_t word_size = process->GetAddressByteSize();
        result += hexStr(sp) + "(+0): SP " +  + "<fill>\n";
        std::vector<uint8_t> buf((fp-sp)+word_size);
        lldb::SBError error;
        process->ReadMemory(sp, buf.data(),(fp-sp)+word_size, error);
        if (error.Fail()) {
            return "Failed to read stack memory.\n";
        }
        for (size_t i = 0; i < (fp-sp)+word_size; i += word_size) {
            uint64_t addr = sp + i;
            uint64_t value = 0;
            memcpy(&value, buf.data() + i, std::min(word_size, sizeof(value)));
            std::stringstream line;
            line << hexStr(addr) << "(+" << i << ")" <<   ": " << hexStr(value);
            uint64_t current = value;
            lldb::SBError error_deref;
            int depth = 0;
            const int max_depth = 5;

            while (depth++ < max_depth) {
                lldb::SBMemoryRegionInfo region;
                if (!process->GetMemoryRegionInfo(current, region).Success() || !region.IsReadable()) {
                    break;
                }

                uint64_t pointee = process->ReadUnsignedFromMemory(current, word_size, error_deref);
                if (!error_deref.Success()) {
                    break;
                }

                line << " → " << hexStr(pointee);

                std::string ascii = peek_ascii(*process, current, 8);
                if (!ascii.empty()) {
                    line << " (\"" << ascii << "\")";
                    break;
                }


                current = pointee;
            }
            result += line.str() + "\n";
        



        }
        result += hexStr(fp) + "(+" + std::to_string((fp-sp)) + "): FP " +  + "<fill>\n";
        
        return result;
    
    }
    std::string derefalg(std::shared_ptr<lldb::SBProcess> process,uint64_t value){
            size_t word_size = process->GetAddressByteSize();
            std::stringstream line;
            uint64_t current = value;
            lldb::SBError error_deref;
            int depth = 0;
            const int max_depth = 5;
            line << "0x" << std::hex << value;
            while (depth++ < max_depth) {
                lldb::SBMemoryRegionInfo region;
                if (!process->GetMemoryRegionInfo(current, region).Success() || !region.IsReadable()) {
                    break;
                }

                uint64_t pointee = process->ReadUnsignedFromMemory(current, word_size, error_deref);
                if (!error_deref.Success()) {
                    break;
                }

                line << " → " << hexStr(pointee);

                std::string ascii = peek_ascii(*process, current, 8);
                if (!ascii.empty()) {
                    line << " (\"" << ascii << "\")";
                    break;
                }


                current = pointee;
            }
            return line.str();
    }
    std::string viewGPRs(activeProcess aP){
        std::string result;
        auto process = aP.activeProc;
        lldb::SBThread thread = process->GetSelectedThread();
        if (!thread.IsValid()) return "Invalid thread.\n";

        lldb::SBFrame frame = thread.GetSelectedFrame();
        
        
        if (!frame.IsValid()) return "Invalid frame.\n";

        auto reg_list = frame.GetRegisters();

        for (int i = 0; i < reg_list.GetSize(); i++){
            auto reg = reg_list.GetValueAtIndex(i);
        
            std::string set_name = reg.GetName();
            

            if (set_name == "General Purpose Registers") {
                for (uint32_t j = 0; j < reg.GetNumChildren(); ++j) {
                    lldb::SBValue reg_val = reg.GetChildAtIndex(j);
                    result += std::string(reg_val.GetName()) + ": " + derefalg(process,reg_val.GetValueAsUnsigned()) + "\n<thinline>\n";
                }
                break;
            }
        }
        return result;
    }

    std::string viewRegs(activeProcess aP){
        std::string result;
        auto process = aP.activeProc;
        lldb::SBThread thread = process->GetSelectedThread();
        if (!thread.IsValid()) return "Invalid thread.\n";

        lldb::SBFrame frame = thread.GetSelectedFrame();
        
        
        if (!frame.IsValid()) return "Invalid frame.\n";

        auto reg_list = frame.GetRegisters();

        for (int i = 0; i < reg_list.GetSize(); i++){
            auto reg = reg_list.GetValueAtIndex(i);
        
            std::string set_name = reg.GetName();
            
            result += set_name + "\n";
            for (uint32_t j = 0; j < reg.GetNumChildren(); ++j) {
                lldb::SBValue reg_val = reg.GetChildAtIndex(j);
                result += std::string(reg_val.GetName()) + ": " + derefalg(process,reg_val.GetValueAsUnsigned()) + "\n<thinline>\n";
            }
            break;
            
        }
        return result;
    }

    std::string viewReg(activeProcess aP,std::string regname){
        std::string result;
        auto process = aP.activeProc;
        lldb::SBThread thread = process->GetSelectedThread();
        if (!thread.IsValid()) return "Invalid thread.\n";

        lldb::SBFrame frame = thread.GetSelectedFrame();
        
        
        if (!frame.IsValid()) return "Invalid frame.\n";

        auto reg_list = frame.GetRegisters();
        bool found = false;

        for (int i = 0; i < reg_list.GetSize(); i++){
            auto reg = reg_list.GetValueAtIndex(i);
        
            std::string set_name = reg.GetName();
            


            for (uint32_t j = 0; j < reg.GetNumChildren(); ++j) {
                lldb::SBValue reg_val = reg.GetChildAtIndex(j);
                if (reg_val.GetName() == regname){
                    result += std::string(reg_val.GetName()) + ": " + derefalg(process,reg_val.GetValueAsUnsigned()) + "\n";
                    found = true;
                    break;
                }

            }
            if (found){
                break;
            }
            
        }
        return result;
    }

    std::string writeRegs(activeProcess aP,std::string reg_name, std::string value){
        auto process = aP.activeProc;
        lldb::SBThread thread = process->GetSelectedThread();
        if (!thread.IsValid()) return "Invalid thread.\n";
        lldb::SBError err;
        lldb::SBFrame frame = thread.GetSelectedFrame();
        
        
        if (!frame.IsValid()) return "Invalid frame.\n";

        auto reg_list = frame.GetRegisters();
        bool found = false;

        for (int i = 0; i < reg_list.GetSize(); i++){
            auto reg = reg_list.GetValueAtIndex(i);
        
            std::string set_name = reg.GetName();
            


            for (uint32_t j = 0; j < reg.GetNumChildren(); ++j) {
                lldb::SBValue reg_val = reg.GetChildAtIndex(j);
                if (reg_val.GetName() == reg_name){

                    reg_val.SetValueFromCString(value.c_str(),err);

                    
                    found = true;
                    break;
                }

            }
            if (found){
                break;
            }
            
        }
        if (err.Fail()){
            return std::string("Failed to write to register: ") + err.GetCString() + ".\n";
        }
        if (!found){
            return "Unable to find register.\n";
        }
        return "Wrote to register.\n";
    }


    std::string writeMem(activeProcess aP,uint64_t addr, std::string value){
        auto process = aP.activeProc;
        lldb::SBError err;
        process->WriteMemory(addr,value.c_str(),value.size(),err);
        if (err.Fail()){
            return std::string("Failed to write memory: ") + err.GetCString() + ".\n";
        }
        return "Wrote to memory.\n";
    }

    std::string writeMemAddr(activeProcess aP, uint64_t addr, uint64_t value) {
        auto process = aP.activeProc;
        lldb::SBError err;
        uint8_t buf[sizeof(uint64_t)];
        std::memcpy(buf, &value, sizeof(value));

        process->WriteMemory(addr, buf, sizeof(buf), err);
        if (err.Fail()) {
            return std::string("Failed to write memory: ") + err.GetCString() + "\n";
        }
        return "Wrote to memory.\n";
    }

    std::string readMem(activeProcess aP,uint64_t addr, uint64_t size){
        std::string result;
        auto process = aP.activeProc;
        lldb::SBError err;
        lldb::SBMemoryRegionInfo region;
        if (!process->GetMemoryRegionInfo(addr, region).Success() || !region.IsReadable()) {
            return "Region/address is not readable.\n";
        }
        std::vector<uint8_t> buffer(size);
        uint32_t remaining = size;
        int chunk = 0;
        while (remaining > 0) {
            uint32_t chunk_size = (remaining >= 8) ? 8 : remaining;
            uint64_t pointee = process->ReadUnsignedFromMemory(addr, chunk_size, err);
            if (!err.Success()) {
                return "Failed to read memory.\n";
                break;
            }
            result += hexStr(pointee) + " ";
            addr += chunk_size;
            remaining -= chunk_size;
            chunk++;
            if (chunk % 2 == 0){
                result += "\n";
            }
        }
        if (err.Fail()){
            return std::string("Failed to read memory: ") + err.GetCString() + ".\n";
        }
        return result;
    }
};



Process proc = Process(server);
activeProcess activeProc = activeProcess(nullptr,nullptr);
#endif